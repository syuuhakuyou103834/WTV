# 完整的用户需求实现
#
# 智能逻辑：只有当没有IQR异常值时才进行最小值删除
# 如果仍有异常值，优先继续异常值检测；如果没有异常值，才进行最小值删除
# 统计完善：异常值和最小值完全分开统计
# 文件命名：根据是否有异常值历史来决定命名规则

import numpy as np
import pandas as pd
import os
import logging
from PyQt5.QtWidgets import QMessageBox, QDialog, QVBoxLayout, QLabel, QPushButton, QApplication, QProgressDialog, QDialogButtonBox
from PyQt5.QtCore import Qt, QTimer, QThread, pyqtSignal
import datetime
from typing import Optional, Tuple, List, Dict, Any

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

print("按用户需求完成逻辑修复，现在应该能正确处理连续的异常值和最小值删除流程")

class OutlierProcessor:
    """增强版异常值处理器类 - 支持完整的分阶段数据优化和用户交互"""

    def __init__(self, etching_ui, main_window, uniformity_threshold):
        """
        初始化异常值处理器

        Args:
            etching_ui: EtchingSimulationUI对象
            main_window: 主窗口对象，用于状态更新
            uniformity_threshold: 均匀性阈值
        """
        self.etching_ui = etching_ui
        self.main_window = main_window
        self.uniformity_threshold = uniformity_threshold
        self.original_file = None
        self.base_original_file = None  # 基础原始文件路径（避免嵌套目录）

        # 初始状态变量（按照用户需求流程图）
        self.outlier_removal_count = 0  # 异常点删除次数
        self.outlier_points_count = 0   # 异常点个数
        self.min_value_removal_count = 0  # 最小值删除个数
        self.outlier_points_list = []   # 异常点列表 [ {'coordinates': (x, y), 'thickness': value}, ... ]
        self.min_value_removal_list = [] # 最小值删除列表 [ {'coordinates': (x, y), 'thickness': value}, ... ]
        self.iqr_outlier_mode = False    # IQR异常点删除模式
        self.min_value_mode = False      # 最小值删除模式

        # 统计变量
        self.total_removed_indices = []
        self.original_count = 0
        self.min_removed_count = 0

        # 增强功能属性
        self.optimization_tracker = None
        self.optimization_history = []
        self.current_optimization_data = None
        self.user_choice_history = []

        # 注意：批量处理功能已移至OutlierBatchProcessor

        # 配置参数
        self.min_data_points = 10  # 最少数据点数
        self.max_outlier_rounds = 20  # 最大异常值处理轮次
        self.data_retention_threshold = 0.3  # 最少保留30%的数据

        logger.info(f"OutlierProcessor 初始化完成，均匀性阈值: {uniformity_threshold}%")

    # 注意：批量处理功能已移至OutlierBatchProcessor
    # 原set_batch_mode方法已移除

    def validate_data_quality(self, data: np.ndarray) -> Dict[str, Any]:
        """
        验证数据质量

        Args:
            data: 数据数组

        Returns:
            dict: 数据质量信息
        """
        if data is None or len(data) == 0:
            return {'valid': False, 'error': '数据为空'}

        if len(data) < self.min_data_points:
            return {'valid': False, 'error': f'数据点数不足，最少需要{self.min_data_points}个点'}

        # 检查数据范围
        x, y, z = data.T
        if np.any(np.isnan(z)) or np.any(np.isinf(z)):
            return {'valid': False, 'error': '厚度数据包含NaN或无穷值'}

        if np.min(z) <= 0:
            return {'valid': False, 'error': '厚度值必须大于0'}

        # 检查坐标范围
        max_coord = max(np.max(np.abs(x)), np.max(np.abs(y)))
        if max_coord > 500:  # 假设晶圆最大半径为500mm
            return {'valid': False, 'error': f'坐标超出合理范围: {max_coord:.2f}mm'}

        return {
            'valid': True,
            'point_count': len(data),
            'thickness_range': (np.min(z), np.max(z)),
            'thickness_mean': np.mean(z),
            'thickness_std': np.std(z),
            'coordinate_range': (np.min(x), np.max(x), np.min(y), np.max(y))
        }

    def _detect_outliers_iqr(self, thickness_values):
        """
        使用IQR方法检测异常值

        Args:
            thickness_values: 厚度值数组

        Returns:
            tuple: (异常值索引数组, 下界, 上界)
        """
        Q1 = np.percentile(thickness_values, 25)
        Q3 = np.percentile(thickness_values, 75)
        IQR = Q3 - Q1
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR

        outlier_mask = (thickness_values < lower_bound) | (thickness_values > upper_bound)
        outlier_indices = np.where(outlier_mask)[0]

        return outlier_indices, lower_bound, upper_bound

    def _save_thickness_data(self, data, filename):
        """
        保存厚度数据到CSV文件

        Args:
            data: 要保存的数据数组 - 可以是不同维度
            filename: 文件名

        Returns:
            bool: 保存是否成功
        """
        try:
            print(f"[DEBUG] _save_thickness_data 开始")
            print(f"[DEBUG] 输入数据类型: {type(data)}")
            print(f"[DEBUG] 输入数据形状: {getattr(data, 'shape', 'N/A')}")

            # 处理不同维度的数据
            if hasattr(data, 'shape'):
                if len(data.shape) == 2:
                    # 2D数组 (N, M)
                    if data.shape[1] >= 3:
                        # 列数足够，使用前3列
                        df_data = data[:, :3]
                        print(f"[DEBUG] 2D数组，列数足够({data.shape[1]})，使用前3列")
                    elif data.shape[1] == 2:
                        # 只有两列，添加thickness列
                        df_data = np.column_stack([data[:, 0], data[:, 1], np.zeros(data.shape[0])])
                        print(f"[DEBUG] 2D数组，只有2列，添加零thickness列")
                    elif data.shape[1] == 1:
                        # 只有1列，创建默认结构
                        df_data = np.column_stack([np.arange(data.shape[0]), data, np.zeros(data.shape[0])])
                        print(f"[DEBUG] 1D数组，创建默认结构")
                    else:
                        print(f"[ERROR] 2D数组列数不足: {data.shape[1]}")
                        if self.main_window:
                            self.main_window.update_status_message(f"数据列数不正确: {data.shape[1]}", "error")
                        return False
                elif len(data.shape) == 1:
                    # 1D数组
                    if data.shape[0] >= 3:
                        # 元素足够，取前3个作为x, y, thickness
                        df_data = np.column_stack([data[:data.shape[0]//3],
                                                data[data.shape[0]//3:data.shape[0]*2//3],
                                                data[data.shape[0]*2//3:]])
                        print(f"[DEBUG] 1D数组，元素足够，创建x,y,thickness结构")
                    else:
                        print(f"[ERROR] 1D数组元素不足: {data.shape[0]}")
                        if self.main_window:
                            self.main_window.update_status_message(f"数据元素不足: {data.shape[0]}", "error")
                        return False
                else:
                    print(f"[ERROR] 数据维度不正确: {getattr(data, 'shape', 'N/A')}")
                    if self.main_window:
                        self.main_window.update_status_message(f"数据格式错误：维度为{getattr(data, 'shape', 'N/A')}", "error")
                    return False

            # 创建DataFrame
            print(f"[DEBUG] 最终数据形状: {df_data.shape}")
            print(f"[DEBUG] 最终数据前3行: {df_data[:3] if len(df_data.shape) == 2 else df_data[:3, :3]}")

            df = pd.DataFrame(df_data, columns=['X', 'Y', 'Thickness'])
            print(f"[DEBUG] 创建DataFrame，形状: {df.shape}")
            print(f"[DEBUG] DataFrame列名: {list(df.columns)}")

            df.to_csv(filename, index=False)
            print(f"[DEBUG] CSV保存完成: {filename}")
            return True

        except Exception as e:
            print(f"[ERROR] _save_thickness_data 失败: {str(e)}")
            import traceback
            print(f"[ERROR] 详细错误: {traceback.format_exc()}")
            if self.main_window:
                self.main_window.update_status_message(f"保存数据失败: {str(e)}", "error")
            return False

    def _read_thickness_data(self, filename):
        """
        从CSV文件读取厚度数据

        Args:
            filename: 文件名

        Returns:
            numpy.ndarray or None: 数据数组或None（如果失败）
        """
        try:
            df = pd.read_csv(filename)
            return df.values
        except Exception as e:
            if self.main_window:
                self.main_window.update_status_message(f"读取数据失败: {str(e)}", "error")
            return None

    def _generate_outlier_filename(self):
        """
        生成异常值剔除后的文件名

        Returns:
            str: 新文件名
        """
        if not self.original_file:
            return "processed_data.csv"

        base_name = os.path.splitext(os.path.basename(self.original_file))[0]
        directory = os.path.dirname(self.original_file)

        if self.outlier_rounds > 0:
            new_filename = f"{base_name}_outlier_round_{self.outlier_rounds}.csv"
        else:
            new_filename = f"{base_name}_outlier_removed.csv"

        return os.path.join(directory, new_filename)

    def _generate_min_removed_filename(self):
        """
        生成最小值剔除后的文件名

        Returns:
            str: 新文件名
        """
        if not self.original_file:
            return "processed_data.csv"

        base_name = os.path.splitext(os.path.basename(self.original_file))[0]
        directory = os.path.dirname(self.original_file)

        if self.outlier_rounds > 0:
            new_filename = f"{base_name}_min_removed_{self.min_removed_count}.csv"
        else:
            new_filename = f"{base_name}_min_removed.csv"

        return os.path.join(directory, new_filename)

    def set_simulation_callback(self, callback_function):
        """
        设置模拟回调函数

        Args:
            callback_function: 回调函数，用于重新启动模拟
        """
        self.simulation_callback = callback_function
        logger.info("模拟回调函数已设置")

    def set_batch_completion_callback(self, callback_function):
        """
        设置批量完成回调函数（用于异常检测完成后继续批量处理）

        Args:
            callback_function: 回调函数，用于通知批量处理器继续下一个文件
        """
        self._batch_completion_callback = callback_function
        logger.info("批量完成回调函数已设置")

    def reset_statistics(self, is_batch_mode=False):
        """重置处理统计状态（按照用户需求流程图初始状态）"""
        logger.info("重置异常值处理统计状态")

        # 重置为初始状态
        self.outlier_removal_count = 0  # 异常点删除次数
        self.outlier_points_count = 0   # 异常点个数
        self.min_value_removal_count = 0  # 最小值删除个数
        self.outlier_points_list = []   # 异常点列表
        self.min_value_removal_list = [] # 最小值删除列表
        self.iqr_outlier_mode = False    # IQR异常点删除模式
        self.min_value_mode = False      # 最小值删除模式

        # 重置其他统计变量
        self.outlier_rounds = 0
        self.total_removed_indices = []
        self.original_count = 0
        self.min_removed_count = 0

        # 修复：批量模式下不要重置文件路径，单片模式下才重置
        if not is_batch_mode:
            self.original_file = None
            self.base_original_file = None
            print(f"[DEBUG] 单片模式：已重置文件路径状态")
        else:
            print(f"[DEBUG] 批量模式：保留文件路径状态用于继续优化")

        # 添加批量处理模式标识
        self.is_batch_mode = is_batch_mode

        # 同步UI中的统计值
        self._sync_ui_statistics()

        if self.main_window:
            self.main_window.update_status_message("异常值处理统计已重置", "info")

    def _sync_ui_statistics(self):
        """同步UI统计显示"""
        if self.etching_ui:
            # 更新UI中的统计值
            if hasattr(self.etching_ui, 'outlier_removal_count'):
                self.etching_ui.outlier_removal_count = self.outlier_removal_count

            if hasattr(self.etching_ui, 'total_removed_points'):
                self.etching_ui.total_removed_points = self.outlier_points_count

            if hasattr(self.etching_ui, 'min_removed_count'):
                self.etching_ui.min_removed_count = self.min_value_removal_count

            # 调用UI更新显示
            if hasattr(self.etching_ui, 'update_process_statistics'):
                self.etching_ui.update_process_statistics()

    def save_initial_file_as_error_deleted_time_0(self, original_file_path):
        """
        步骤1: 将初始膜厚文件另存为"原文件名_error_deleted_0_time"

        Args:
            original_file_path: 原始文件路径

        Returns:
            str: 另存为的文件路径
        """
        try:
            if not original_file_path:
                logger.error("original_file_path为None，无法另存初始文件")
                return None

            # 修复：检查是否已经存在_error_deleted_0_time文件
            base_name = os.path.splitext(os.path.basename(original_file_path))[0]
            directory = os.path.dirname(original_file_path)
            new_filename = f"{base_name}_error_deleted_0_time.csv"
            new_file_path = os.path.join(directory, new_filename)

            # 如果文件已存在，直接返回，避免重复生成
            if os.path.exists(new_file_path):
                print(f"[DEBUG] _error_deleted_0_time文件已存在，直接使用: {new_file_path}")
                # 更新当前处理文件
                self.original_file = new_file_path
                # 读取数据点数量
                df = pd.read_csv(new_file_path)
                self.original_count = len(df)
                logger.info(f"步骤1完成: 使用已存在的 {new_file_path}")
                return new_file_path

            # 设置基础原始文件路径
            if not self.base_original_file:
                self.base_original_file = original_file_path
                self.original_file = original_file_path  # 同时设置当前文件路径

            # 读取原始数据并保存
            df = pd.read_csv(original_file_path)
            df.to_csv(new_file_path, index=False)

            # 更新当前处理文件
            self.original_file = new_file_path
            self.original_count = len(df)

            logger.info(f"步骤1完成: 初始文件另存为 {new_file_path}")
            if self.main_window:
                self.main_window.update_status_message(f"初始文件已另存为: {new_filename}", "info")

            return new_file_path

        except Exception as e:
            logger.error(f"步骤1失败: 另存为文件失败: {str(e)}")
            if self.main_window:
                self.main_window.update_status_message(f"另存为文件失败: {str(e)}", "error")
            return None

    def check_iqr_outliers(self, data):
        """
        步骤6: 检测当前膜厚文件是否存在基于IQR的异常点

        Args:
            data: 当前膜厚数据 (numpy.ndarray, shape [N, 3])

        Returns:
            tuple: (是否存在异常点, 异常点列表, 异常点详细信息)
        """
        try:
            if data is None or len(data) == 0:
                return False, [], []

            if not self.original_file:
                logger.error("original_file为None，无法进行IQR异常点检测")
                return False, [], []

            thickness_values = data[:, 2]
            outlier_indices, lower_bound, upper_bound, outlier_details = self._detect_outliers_1_5_iqr(thickness_values)

            outlier_points = []
            for idx in outlier_indices:
                point_info = {
                    'index': int(idx),
                    'coordinates': (float(data[idx, 0]), float(data[idx, 1])),
                    'thickness': float(data[idx, 2])
                }
                outlier_points.append(point_info)

            has_outliers = len(outlier_points) > 0

            logger.info(f"步骤6完成: IQR异常点检测，发现 {len(outlier_points)} 个异常点")
            if self.main_window:
                self.main_window.update_status_message(f"IQR异常点检测完成: 发现 {len(outlier_points)} 个异常点", "info")

            return has_outliers, outlier_points, outlier_details

        except Exception as e:
            logger.error(f"步骤6失败: IQR异常点检测失败: {str(e)}")
            if self.main_window:
                self.main_window.update_status_message(f"IQR异常点检测失败: {str(e)}", "error")
            return False, [], []

    def show_outlier_points_dialog(self, outlier_points):
        """
        步骤11: 弹窗告知用户所有存在异常点的坐标和厚度，并询问用户是否删除异常点并再次模拟

        Args:
            outlier_points: 异常点列表

        Returns:
            bool: 用户选择是否删除异常点
        """
        try:
            from PyQt5.QtWidgets import QMessageBox, QDialog, QVBoxLayout, QLabel, QPushButton, QTextEdit

            dialog = QDialog(self.etching_ui)
            dialog.setWindowTitle("步骤11 - 异常点确认")
            dialog.setMinimumSize(700, 600)
            dialog.setModal(True)

            layout = QVBoxLayout(dialog)

            # 创建详细信息文本
            details_text = f"""<h3>步骤11 - 异常点检测确认</h3>

            <p><b>检测到异常点数量：</b> {len(outlier_points)}</p>
            <p><b>是否要删除这些异常点并重新模拟？</b></p>

            <h4>异常点详情：</h4>
            <table border='1' cellpadding='5' cellspacing='0' width='100%'>
            <tr><th>序号</th><th>X坐标 (mm)</th><th>Y坐标 (mm)</th><th>厚度 (nm)</th></tr>"""

            for i, point in enumerate(outlier_points[:20]):  # 只显示前20个
                x, y = point['coordinates']
                thickness = point['thickness']
                details_text += f"""
                <tr>
                    <td>{i+1}</td>
                    <td>{x:.2f}</td>
                    <td>{y:.2f}</td>
                    <td>{thickness:.2f}</td>
                </tr>"""

            details_text += "</table>"

            if len(outlier_points) > 20:
                details_text += f"<p><em>... 还有 {len(outlier_points) - 20} 个异常点未显示</em></p>"

            text_widget = QTextEdit()
            text_widget.setHtml(details_text)
            text_widget.setReadOnly(True)

            layout.addWidget(text_widget)

            # 按钮
            button_box = QDialogButtonBox(QDialogButtonBox.Yes | QDialogButtonBox.No)
            button_box.accepted.connect(dialog.accept)
            button_box.rejected.connect(dialog.reject)
            layout.addWidget(button_box)

            # 修改按钮文本
            button_box.button(QDialogButtonBox.Yes).setText("删除异常点并重新模拟")
            button_box.button(QDialogButtonBox.No).setText("结束")

            result = dialog.exec_() == QDialog.Accepted

            logger.info(f"步骤11完成: 用户选择{'删除' if result else '结束'}异常点处理")
            return result

        except Exception as e:
            logger.error(f"步骤11失败: 显示异常点对话框失败: {str(e)}")
            if self.main_window:
                self.main_window.update_status_message(f"显示异常点对话框失败: {str(e)}", "error")
            return False

    def enter_iqr_outlier_mode(self):
        """步骤13: 进入IQR异常点删除模式"""
        self.iqr_outlier_mode = True
        self.min_value_mode = False

        logger.info("步骤13完成: 进入IQR异常点删除模式")
        if self.main_window:
            self.main_window.update_status_message("已进入IQR异常点删除模式", "info")

    def increment_outlier_removal_count(self):
        """步骤14: 异常点删除次数=异常点删除次数+1"""
        self.outlier_removal_count += 1
        logger.info(f"步骤14完成: 异常点删除次数更新为 {self.outlier_removal_count}")

        if self.main_window:
            self.main_window.update_status_message(f"异常点删除次数: {self.outlier_removal_count}", "info")

        # 更新UI中的异常值剔除次数显示
        if self.etching_ui and hasattr(self.etching_ui, 'increment_outlier_removal_count'):
            self.etching_ui.increment_outlier_removal_count()

    def save_file_with_outlier_removal(self, data, outlier_indices):
        """
        步骤15: 将检测的初始膜厚文件删去异常点并另存为

        Args:
            data: 原始数据
            outlier_indices: 要删除的异常点索引

        Returns:
            str: 新文件路径
        """
        try:
            # 确保有原始文件路径
            if not self.original_file and not self.base_original_file:
                logger.error("original_file和base_original_file都为None，无法保存异常点删除文件")
                return None

            # 使用base_original_file作为基础路径（如果存在）
            base_file_path = self.base_original_file if self.base_original_file else self.original_file
            if not base_file_path:
                logger.error("无法确定基础文件路径，无法保存异常点删除文件")
                return None

            # 删除异常点
            mask = np.ones(len(data), dtype=bool)
            mask[outlier_indices] = False
            cleaned_data = data[mask]

            # 生成文件名: 原文件名_error_deleted_m_time
            base_name = os.path.splitext(os.path.basename(base_file_path))[0]
            directory = os.path.dirname(base_file_path)
            new_filename = f"{base_name}_error_deleted_{self.outlier_removal_count}_time.csv"

            # 单片处理：直接保存到原文件目录
            new_file_path = os.path.join(directory, new_filename)

            # 保存文件
            if self._save_thickness_data(cleaned_data, new_file_path):
                # 添加到异常点列表
                for idx in outlier_indices:
                    point_info = {
                        'index': int(idx),
                        'coordinates': (float(data[idx, 0]), float(data[idx, 1])),
                        'thickness': float(data[idx, 2]),
                        'removal_round': self.outlier_removal_count
                    }
                    self.outlier_points_list.append(point_info)

                # 修复：异常点总数应该等于列表长度，而不是累加
                self.outlier_points_count = len(self.outlier_points_list)

                # 更新当前处理文件
                self.original_file = new_file_path

                # 更新UI中的已剔除异常点个数
                if self.etching_ui and hasattr(self.etching_ui, 'total_removed_points'):
                    self.etching_ui.total_removed_points = self.outlier_points_count
                    self.etching_ui.update_process_statistics()

                logger.info(f"步骤15完成: 异常点删除文件保存为 {new_file_path}，已删除异常点总数: {self.outlier_points_count}")
                if self.main_window:
                    self.main_window.update_status_message(f"异常点删除完成，文件保存为: {new_filename}，已删除{len(outlier_indices)}个异常点，总计{self.outlier_points_count}个", "info")

                return new_file_path
            else:
                logger.error("步骤15失败: 保存异常点删除文件失败")
                return None

        except Exception as e:
            logger.error(f"步骤15失败: 保存异常点删除文件时出错: {str(e)}")
            if self.main_window:
                self.main_window.update_status_message(f"保存异常点删除文件失败: {str(e)}", "error")
            return None

    def show_min_value_mode_dialog(self):
        """
        步骤8: 弹窗告知用户结果询问是否进入最小值删除模式

        Returns:
            bool: 用户选择是否进入最小值删除模式
        """
        try:
            from PyQt5.QtWidgets import QMessageBox

            title = "步骤8 - 进入最小值删除模式"
            message = "IQR异常点检测完成，未发现异常点。\n\n"
            message += "当前没有IQR异常点，是否进入最小值删除模式？\n"
            message += "(逐轮删除最小值点并重新模拟)"

            reply = QMessageBox.question(
                self.etching_ui,
                title,
                message,
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No  # 默认选择否
            )

            result = reply == QMessageBox.Yes

            logger.info(f"步骤8完成: 用户选择{'进入' if result else '不进入'}最小值删除模式")
            return result

        except Exception as e:
            logger.error(f"步骤8失败: 显示最小值删除模式对话框失败: {str(e)}")
            if self.main_window:
                self.main_window.update_status_message(f"显示对话框失败: {str(e)}", "error")
            return False

    def detect_current_min_value_point(self, data):
        """
        步骤17: 检测当前膜厚文件的最小值的坐标和膜厚

        Args:
            data: 当前膜厚数据 (numpy.ndarray, shape [N, 3])

        Returns:
            dict: 最小值点信息 {'coordinates': (x, y), 'thickness': value, 'index': idx}
        """
        try:
            if data is None or len(data) == 0:
                return None

            thickness_values = data[:, 2]
            min_index = np.argmin(thickness_values)
            min_thickness = thickness_values[min_index]
            min_x, min_y = data[min_index, 0], data[min_index, 1]

            min_point_info = {
                'index': int(min_index),
                'coordinates': (float(min_x), float(min_y)),
                'thickness': float(min_thickness)
            }

            logger.info(f"步骤17完成: 检测到最小值点 ({min_x:.2f}, {min_y:.2f}) 厚度 {min_thickness:.2f} nm")
            if self.main_window:
                self.main_window.update_status_message(f"检测到最小值点: 厚度 {min_thickness:.2f} nm", "info")

            return min_point_info

        except Exception as e:
            logger.error(f"步骤17失败: 检测最小值点失败: {str(e)}")
            if self.main_window:
                self.main_window.update_status_message(f"检测最小值点失败: {str(e)}", "error")
            return None

    def show_min_value_removal_dialog(self, min_point_info, min_value_list):
        """
        步骤18: 将最小值删除列表中所有最小值点的坐标和膜厚告知用户，并询问是否删除一个最小值点后再次模拟

        Args:
            min_point_info: 当前检测到的最小值点信息
            min_value_list: 历史最小值删除列表

        Returns:
            bool: 用户选择是否删除最小值点
        """
        try:
            from PyQt5.QtWidgets import QDialog, QVBoxLayout, QLabel, QPushButton, QTextEdit

            dialog = QDialog(self.etching_ui)
            dialog.setWindowTitle("步骤18 - 最小值删除确认")
            dialog.setMinimumSize(700, 600)
            dialog.setModal(True)

            layout = QVBoxLayout(dialog)

            # 创建详细信息文本
            details_text = f"""<h3>步骤18 - 最小值删除确认</h3>

            <p><b>当前检测到的最小值点：</b></p>
            <p>坐标: ({min_point_info['coordinates'][0]:.2f}, {min_point_info['coordinates'][1]:.2f}) mm</p>
            <p>厚度: {min_point_info['thickness']:.2f} nm</p>

            <p><b>历史最小值删除列表（共 {len(min_value_list)} 个点）：</b></p>

            <h4>历史最小值点详情：</h4>
            <table border='1' cellpadding='5' cellspacing='0' width='100%'>
            <tr><th>序号</th><th>X坐标 (mm)</th><th>Y坐标 (mm)</th><th>厚度 (nm)</th></tr>"""

            # 显示历史删除的最小值点
            for i, point in enumerate(min_value_list[-20:]):  # 只显示最近20个
                x, y = point['coordinates']
                thickness = point['thickness']
                details_text += f"""
                <tr>
                    <td>{i+1}</td>
                    <td>{x:.2f}</td>
                    <td>{y:.2f}</td>
                    <td>{thickness:.2f}</td>
                </tr>"""

            if len(min_value_list) > 20:
                details_text += f"<p><em>... 还有 {len(min_value_list) - 20} 个历史最小值点未显示</em></p>"

            details_text += f"""
            </table>

            <p><b>是否删除当前最小值点并重新模拟？</b></p>"""

            text_widget = QTextEdit()
            text_widget.setHtml(details_text)
            text_widget.setReadOnly(True)

            layout.addWidget(text_widget)

            # 按钮
            button_box = QDialogButtonBox(QDialogButtonBox.Yes | QDialogButtonBox.No)
            button_box.accepted.connect(dialog.accept)
            button_box.rejected.connect(dialog.reject)
            layout.addWidget(button_box)

            # 修改按钮文本
            button_box.button(QDialogButtonBox.Yes).setText("删除最小值点并重新模拟")
            button_box.button(QDialogButtonBox.No).setText("结束")

            result = dialog.exec_() == QDialog.Accepted

            logger.info(f"步骤18完成: 用户选择{'删除' if result else '结束'}最小值点")
            return result

        except Exception as e:
            logger.error(f"步骤18失败: 显示最小值删除对话框失败: {str(e)}")
            if self.main_window:
                self.main_window.update_status_message(f"显示最小值删除对话框失败: {str(e)}", "error")
            return False

    def enter_min_value_mode(self):
        """步骤9: 退出异常点删除模式，进入最小值删除模式"""
        self.iqr_outlier_mode = False
        self.min_value_mode = True

        logger.info("步骤9完成: 已退出异常点删除模式，进入最小值删除模式")
        if self.main_window:
            self.main_window.update_status_message("已进入最小值删除模式", "info")

    def increment_min_value_removal_count(self):
        """步骤21: 最小值删除个数=最小值删除个数+1"""
        self.min_value_removal_count += 1

        logger.info(f"步骤21完成: 最小值删除个数更新为 {self.min_value_removal_count}")
        if self.main_window:
            self.main_window.update_status_message(f"最小值删除个数: {self.min_value_removal_count}", "info")

        # 更新UI中的最小值删除个数显示
        if self.etching_ui and hasattr(self.etching_ui, 'min_removed_count'):
            self.etching_ui.min_removed_count = self.min_value_removal_count
            self.etching_ui.update_process_statistics()

    def save_file_with_min_value_removal(self, data, min_point_info):
        """
        步骤22: 把删除了一个最小值点的文件另存为指定格式

        Args:
            data: 删除最小值点后的数据
            min_point_info: 被删除的最小值点信息

        Returns:
            str: 新文件路径
        """
        try:
            # 确保有原始文件路径
            if not self.base_original_file and not self.original_file:
                logger.error("无法确定基础原始文件路径，无法保存最小值删除结果")
                return None

            # 使用base_original_file作为基础路径
            base_file_path = self.base_original_file if self.base_original_file else self.original_file
            if not base_file_path:
                logger.error("基础文件路径为空，无法保存最小值删除结果")
                return None

            # 生成文件名: 当前文件名_error_deleted_m_time_min_removed_n
            base_name = os.path.splitext(os.path.basename(base_file_path))[0]
            directory = os.path.dirname(base_file_path)

            # 确定当前异常点删除次数（m）
            current_error_deleted_count = self.outlier_removal_count

            new_filename = f"{base_name}_error_deleted_{current_error_deleted_count}_time_min_removed_{self.min_value_removal_count}.csv"

            # 单片处理：直接保存到原文件目录
            new_file_path = os.path.join(directory, new_filename)

            # 保存文件
            if self._save_thickness_data(data, new_file_path):
                # 添加到最小值删除列表
                min_point_info['removal_round'] = self.min_value_removal_count
                self.min_value_removal_list.append(min_point_info)

                # 更新当前处理文件
                self.original_file = new_file_path

                # 更新UI中的已删除最小值点个数
                if self.etching_ui and hasattr(self.etching_ui, 'min_removed_count'):
                    self.etching_ui.min_removed_count = self.min_value_removal_count
                    self.etching_ui.update_process_statistics()

                logger.info(f"步骤22完成: 最小值删除文件保存为 {new_file_path}")
                if self.main_window:
                    self.main_window.update_status_message(f"最小值删除完成，文件保存为: {new_filename}", "info")

                return new_file_path
            else:
                logger.error("步骤22失败: 保存最小值删除文件失败")
                return None

        except Exception as e:
            logger.error(f"步骤22失败: 保存最小值删除文件时出错: {str(e)}")
            if self.main_window:
                self.main_window.update_status_message(f"保存最小值删除文件失败: {str(e)}", "error")
            return None

    def get_current_statistics(self):
        """
        获取当前处理统计信息

        Returns:
            dict: 当前统计信息
        """
        return {
            'outlier_removal_count': self.outlier_removal_count,
            'outlier_points_count': self.outlier_points_count,
            'min_value_removal_count': self.min_value_removal_count,
            'outlier_points_list': self.outlier_points_list,
            'min_value_removal_list': self.min_value_removal_list,
            'iqr_outlier_mode': self.iqr_outlier_mode,
            'min_value_mode': self.min_value_mode
        }

    def _detect_outliers_1_5_iqr(self, thickness_values):
        """
        使用1.5倍四分位距检测异常值（参考batch_wafer_ui.py中的方法）

        Args:
            thickness_values: 厚度值数组

        Returns:
            tuple: (异常值索引数组, 下界, 上界, 异常值详细信息)
        """
        print(f"[DEBUG] _detect_outliers_1_5_iqr 开始")
        print(f"[DEBUG] 输入数组长度: {len(thickness_values)}")
        print(f"[DEBUG] 数组类型: {type(thickness_values)}")

        try:
            Q1 = np.percentile(thickness_values, 25)
            Q3 = np.percentile(thickness_values, 75)
            IQR = Q3 - Q1
            lower_bound = Q1 - 1.5 * IQR
            upper_bound = Q3 + 1.5 * IQR

            outlier_mask = (thickness_values < lower_bound) | (thickness_values > upper_bound)
            outlier_indices = np.where(outlier_mask)[0]

            # 添加调试信息
            print(f"[DEBUG] 异常值检测统计:")
            print(f"[DEBUG] 数据点总数: {len(thickness_values)}")
            print(f"[DEBUG] Q1 (25%分位数): {Q1:.2f}")
            print(f"[DEBUG] Q3 (75%分位数): {Q3:.2f}")
            print(f"[DEBUG] IQR (四分位距): {IQR:.2f}")
            print(f"[DEBUG] 异常值下界: {lower_bound:.2f}")
            print(f"[DEBUG] 异常值上界: {upper_bound:.2f}")
            print(f"[DEBUG] 检测到异常值数量: {len(outlier_indices)}")

            if len(outlier_indices) > 0:
                print(f"[DEBUG] 异常值索引: {outlier_indices}")
                print(f"[DEBUG] 异常值: {[thickness_values[i] for i in outlier_indices]}")

            # 生成异常值详细信息
            outlier_details = []
            for idx in outlier_indices:
                outlier_details.append({
                    'index': int(idx),
                    'value': float(thickness_values[idx]),
                    'difference_from_upper': float(thickness_values[idx] - upper_bound),
                    'difference_from_lower': float(lower_bound - thickness_values[idx])
                })

            print(f"[DEBUG] _detect_outliers_1_5_iqr 即将返回")

            # 确保返回4个值：indices, lower_bound, upper_bound, details
            return outlier_indices, lower_bound, upper_bound, outlier_details

        except Exception as e:
            print(f"[ERROR] _detect_outliers_1_5_iqr 失败: {str(e)}")
            import traceback
            print(f"[ERROR] 详细错误: {traceback.format_exc()}")
            # 返回空结果
            return np.array([]), 0.0, 0.0, []

    def _detect_and_remove_outliers_batch(self, current_data):
        """
        批量检测和移除异常值（根据您的需求）

        Args:
            current_data: 当前厚度数据 (numpy.ndarray, shape [N, 3])

        Returns:
            tuple: (新数据, 移除的异常值信息, 剩余数据统计)
        """
        thickness_values = current_data[:, 2]
        original_count = len(current_data)

        # 第一轮：检测并移除异常值
        outlier_indices_1, lower_bound_1, upper_bound_1, outlier_details_1 = self._detect_outliers_1_5_iqr(thickness_values)

        new_data_1 = current_data.copy()
        mask_1 = np.ones(len(current_data), dtype=bool)
        mask_1[outlier_indices_1] = False
        new_data_1 = new_data_1[mask_1]
        remaining_count_1 = len(new_data_1)
        removal_percentage_1 = (len(outlier_indices_1) / original_count) * 100

        # 检查是否低于80%
        below_80_percent_1 = remaining_count_1 < (original_count * 0.8)

        # 第二轮：检测并移除最小值
        thickness_values_1 = new_data_1[:, 2]
        min_index_1 = np.argmin(thickness_values_1)
        new_data_2 = new_data_1.copy()
        mask_2 = np.ones(len(new_data_1), dtype=bool)
        mask_2[min_index_1] = False
        new_data_2 = new_data_2[mask_2]
        remaining_count_2 = len(new_data_2)
        removal_percentage_2 = (original_count - remaining_count_2) * 100

        # 第三轮：检测并移除最小值
        thickness_values_2 = new_data_2[:, 2]
        min_index_2 = np.argmin(thickness_values_2)
        new_data_3 = new_data_2.copy()
        mask_3 = np.ones(len(new_data_2), dtype=bool)
        mask_3[min_index_2] = False
        new_data_3 = new_data_3[mask_3]
        remaining_count_3 = len(new_data_3)
        removal_percentage_3 = (original_count - remaining_count_3) * 100

        # 生成详细信息
        outlier_summary = {
            'original_count': original_count,
            'round_1': {
                'type': 'IQR异常值检测',
                'outlier_indices': [int(idx) for idx in outlier_indices_1],
                'outlier_count': len(outlier_indices_1),
                'lower_bound': float(lower_bound_1),
                'upper_bound': float(upper_bound_1),
                'remaining_count': remaining_count_1,
                'removal_percentage': float(removal_percentage_1),
                'below_80_percent': below_80_percent_1
            },
            'round_2': {
                'type': '最小值移除',
                'min_index': int(min_index_1),
                'min_value': float(thickness_values_1[min_index_1]),
                'remaining_count': remaining_count_2,
                'total_removed_count': original_count - remaining_count_2,
                'removal_percentage': float(removal_percentage_2)
            },
            'round_3': {
                'type': '最小值移除',
                'min_index': int(min_index_2),
                'min_value': float(thickness_values_2[min_index_2]),
                'remaining_count': remaining_count_3,
                'total_removed_count': original_count - remaining_count_3,
                'removal_percentage': float(removal_percentage_3)
            }
        }

        return new_data_3, outlier_summary, {
            'min': float(np.min(new_data_3[:, 2])),
            'max': float(np.max(new_data_3[:, 2])),
            'mean': float(np.mean(new_data_3[:, 2])),
            'range': float(np.max(new_data_3[:, 2]) - np.min(new_data_3[:, 2])),
            'count': len(new_data_3)
        }

    def _show_outlier_removal_summary_dialog(self, original_count, removed_indices, outlier_details, threshold_exceeded=False):
        """
        显示异常值移除摘要对话框

        Args:
            original_count: 原始数据点数
            removed_indices: 被移除的异常值索引
            outlier_details: 异常值详细信息
            threshold_exceeded: 是否超过阈值
        """
        try:
            from PyQt5.QtWidgets import QDialog, QVBoxLayout, QLabel, QPushButton, QTextEdit
            from PyQt5.QtCore import Qt

            dialog = QDialog(self.etching_ui if hasattr(self, 'etching_ui') else None)
            dialog.setWindowTitle("异常值检测摘要")
            dialog.setMinimumSize(600, 500)
            dialog.setModal(True)

            layout = QVBoxLayout(dialog)

            # 创建详细信息文本
            details_text = f"""<h3>异常值检测摘要</h3>

            <p><b>原始数据点数：</b> {original_count}</p>
            <p><b>检测到异常值数量：</b> {len(removed_indices)}</p>
            <p><b>异常值比例：</b> {(len(removed_indices)/original_count)*100:.2f}%</p>

            <h4>异常值详情：</h4>
            <table border='1' cellpadding='5' cellspacing='0'>
            <tr><th>序号</th><th>厚度值</th><th>超出上限</th><th>超出下限</th></tr>"""

            for i, idx in enumerate(removed_indices[:10]):  # 只显示前10个
                detail = outlier_details[i] if i < len(outlier_details) else {'value': 0, 'difference_from_upper': 0, 'difference_from_lower': 0}
                details_text += f"""
                <tr>
                    <td>{i+1}</td>
                    <td>{detail['value']:.2f} nm</td>
                    <td style='color: red;'>{detail['difference_from_upper']:.2f} nm</td>
                    <td style='color: blue;'>{detail['difference_from_lower']:.2f} nm</td>
                </tr>"""

            details_text += "</table>"

            if len(removed_indices) > 10:
                details_text += f"<p><em>... 还有 {len(removed_indices) - 10} 个异常值未显示</em></p>"

            if threshold_exceeded:
                details_text += "<p><b style='color: red;'>⚠️ 剩余数据点数少于原始数据的80%，建议谨慎继续！</b></p>"

            text_widget = QTextEdit()
            text_widget.setHtml(details_text)
            text_widget.setReadOnly(True)

            layout.addWidget(text_widget)

            # 按钮
            button_box = QDialogButtonBox(QDialogButtonBox.Ok)
            button_box.accepted.connect(dialog.accept)
            layout.addWidget(button_box)

            dialog.exec_()

        except Exception as e:
            logger.error(f"显示异常值移除摘要对话框失败: {e}")
            if self.main_window:
                self.main_window.update_status_message(f"显示摘要对话框失败: {str(e)}", "error")

    def _check_data_quality_after_removal(self, original_data, processed_data):
        """
        检查数据处理后的质量

        Args:
            original_data: 原始数据
            processed_data: 处理后数据

        Returns:
            dict: 质量检查结果
        """
        quality_result = {
            'valid': True,
            'original_count': len(original_data),
            'processed_count': len(processed_data),
            'removed_count': len(original_data) - len(processed_data),
            'removal_percentage': ((len(original_data) - len(processed_data)) / len(original_data)) * 100,
            'below_80_percent': len(processed_data) < (len(original_data) * 0.8)
        }

        # 检查最小数据点数
        if len(processed_data) < self.min_data_points:
            quality_result['valid'] = False
            quality_result['error'] = f"数据点数过少：{len(processed_data)}，最少需要{self.min_data_points}个点"

        # 检查数据范围
        original_thickness = original_data[:, 2]
        processed_thickness = processed_data[:, 2]

        if np.mean(processed_thickness) <= 0:
            quality_result['valid'] = False
            quality_result['error'] = "处理后平均厚度值小于等于0"

        return quality_result

    def _remove_outliers_and_save(self, data, outlier_indices, round_num):
        """
        移除异常值并保存文件

        Args:
            data: 原始数据数组 (N, 3) - [x, y, thickness]
            outlier_indices: 异常值索引数组
            round_num: 当前轮次

        Returns:
            tuple: (新数据数组, 剩余数据量)
        """
        if len(outlier_indices) == 0:
            return data, len(data)

        mask = np.ones(len(data), dtype=bool)
        mask[outlier_indices] = False
        new_data = data[mask]

        # 保存移除异常值后的文件（区分批量和单片处理）
        base_name = os.path.splitext(os.path.basename(self.original_file))[0]
        new_filename = f"{base_name}_error_deleted_{round_num}_time.csv"

        # 单片处理：直接保存到原文件目录
        new_file_path = os.path.join(os.path.dirname(self.original_file), new_filename)

        if self._save_thickness_data(new_data, new_file_path):
            if self.main_window:
                removed_count = len(data) - len(new_data)
                remaining_count = len(new_data)
                original_count = self.original_count if self.original_count > 0 else len(data)
                percentage = (remaining_count / original_count) * 100 if original_count > 0 else 100
                message = f"第{round_num}轮异常值处理完成:\n"
                message += f"- 删除了 {removed_count} 个异常点\n"
                message += f"- 剩余 {remaining_count} 个数据点 ({percentage:.1f}%)\n"
                message += f"- 异常值检测使用1.5倍四分位距方法\n"
                message += f"- 文件已保存为: {new_filename}"

                self.main_window.update_status_message(message, "info")

        return new_data, len(new_data)

    def _remove_min_values_and_save(self, data, removed_count, total_removed_points):
        """
        移除最小值并保存文件

        Args:
            data: 当前数据数组
            removed_count: 已移除的最小值数量
            total_removed_points: 总共移除的点数

        Returns:
            tuple: (新数据数组, 移除的最小值索引)
        """
        if len(data) == 0:
            return data, -1

        thickness_values = data[:, 2]
        min_index = np.argmin(thickness_values)

        mask = np.ones(len(data), dtype=bool)
        mask[min_index] = False
        new_data = data[mask]

        # 保存移除最小值后的文件
        new_removed_count = removed_count + 1
        base_name = os.path.splitext(os.path.basename(self.original_file))[0]

        if self.outlier_rounds > 0:
            new_filename = f"{base_name}_error_deleted_{self.outlier_rounds}_time_min_removed_{new_removed_count}.csv"
        else:
            new_filename = f"{base_name}_min_removed_{new_removed_count}.csv"

        new_file_path = os.path.join(os.path.dirname(self.original_file), new_filename)

        if self._save_thickness_data(new_data, new_file_path):
            if self.main_window:
                remaining_count = len(new_data)
                original_count = self.original_count if self.original_count > 0 else len(data)
                percentage = (remaining_count / original_count) * 100 if original_count > 0 else 100

                message = f"第{new_removed_count}个最小值移除完成:\n"
                message += f"- 剩余 {remaining_count} 个数据点 ({percentage:.1f}%)\n"
                message += f"- 相比原始文件 {os.path.basename(self.original_file)} 共移除了 {total_removed_points + 1} 个异常点\n"
                message += f"- 文件已保存为: {new_filename}"

                self.main_window.update_status_message(message, "info")

        return new_data, min_index

    def handle_simulation_completed(self, results, unity_msg, validated_stats, auto_optimize=True):
        """
        处理模拟完成的结果 - 按照用户需求流程图实现

        Args:
            results: 模拟结果
            unity_msg: 均匀性消息
            validated_stats: 验证统计信息
            auto_optimize: 是否自动优化（默认True）
        """
        import datetime

        print(f"[LOG {datetime.datetime.now()}] ===== 开始按照用户需求流程图处理 =====")

        if not results:
            return

        # 获取模拟结果数据
        initial_thickness_data = results.get('initial_thickness_data')
        validated_thickness_data = results.get('validated_thickness_data')

        # 修复：优先使用self.original_file（已更新的文件路径），只有在没有时才使用results中的原始路径
        if self.original_file:
            original_file = self.original_file
            print(f"[DEBUG] 使用更新后的文件路径: {original_file}")
        else:
            original_file = results.get('original_etching_file')
            if original_file:
                print(f"[DEBUG] 使用results中的原始文件路径: {original_file}")

        if not original_file:
            print(f"[ERROR] 无法确定文件路径")
            return

        # 检查均匀性是否达标
        if 'uniformity' in validated_stats:
            uniformity = validated_stats['uniformity']
            uniformity_threshold = self.uniformity_threshold

            if uniformity <= uniformity_threshold:
                # 步骤3: 步骤2的模拟结果验算后的均一性满足用户设定的阈值 ── 步骤4: 弹窗告知用户结果 ── 结束
                self._show_uniformity_success_dialog(validated_stats, unity_msg)
                return
            else:
                # 步骤5: 步骤2的模拟结果不满足用户设定的阈值
                print(f"[DEBUG] 步骤5完成: 均匀性不达标 ({uniformity:.2f}% > {uniformity_threshold:.2f}%)，继续步骤6")

        # 步骤6: 检测步骤2使用的初始膜厚文件是否存在基于IQR的异常点
        # 获取当前用于模拟的数据
        current_file = self.original_file

        # 修复：如果self.original_file为None，说明这是第一次调用，需要初始化
        if not current_file:
            # 第一次调用时，使用原始文件并保存为_error_deleted_0_time.csv
            current_file = original_file
            print(f"[DEBUG] 首次异常检测，初始化文件路径: {current_file}")

            # 步骤1: 将初始膜厚文件另存为为"原文件名_error_deleted_异常点删除次数_time"
            saved_file = self.save_initial_file_as_error_deleted_time_0(current_file)
            if not saved_file:
                logger.error("步骤1失败: 无法另存初始文件")
                return
            current_file = saved_file
            print(f"[DEBUG] 已初始化当前文件: {current_file}")
        else:
            # 后续调用时，直接使用已更新的original_file
            print(f"[DEBUG] 使用更新后的文件继续异常检测: {current_file}")

        print(f"[DEBUG] 步骤6开始: 检测IQR异常点，文件: {current_file}")

        # 读取当前文件数据
        try:
            df = pd.read_csv(current_file)
            current_data = df.iloc[:, [0, 1, 2]].values
            print(f"[DEBUG] 读取当前数据: {current_data.shape}")
        except Exception as e:
            logger.error(f"步骤6失败: 读取当前文件失败: {str(e)}")
            if self.main_window:
                self.main_window.update_status_message(f"读取当前文件失败: {str(e)}", "error")
            return

        # 检测IQR异常点
        has_outliers, outlier_points, outlier_details = self.check_iqr_outliers(current_data)

        if not has_outliers:
            # 步骤7: 步骤6的检测结果不存在异常点 ── 步骤8: 弹窗告知用户结果询问是否进入最小值删除模式（Yes or no）
            print(f"[DEBUG] 步骤7完成: 未检测到IQR异常点，进入步骤8")

            # 询问用户是否进入最小值删除模式
            should_enter_min_value_mode = self.show_min_value_mode_dialog()

            if not should_enter_min_value_mode:
                # 步骤10: 如果用户在步骤8选择no，则结束
                print(f"[DEBUG] 步骤10完成: 用户选择不进入最小值删除模式，结束")
                self._show_uniformity_failure_dialog(validated_stats, unity_msg)
                return

            # 步骤9: 如果用户在步骤8选择yes，则退出异常点删除模式，进入最小值删除模式
            print(f"[DEBUG] 步骤9完成: 用户同意进入最小值删除模式")
            self.enter_min_value_mode()

            # 启动最小值删除流程 - 使用当前已经没有IQR异常点的文件
            self._start_min_value_removal_flow(current_data, validated_stats, unity_msg)
            return

        # 步骤10: 步骤6的检测结果存在n个异常点，异常点个数=异常点个数+n，将这n个点的坐标和膜厚追加到异常点列表[]
        outlier_count = len(outlier_points)
        # 修复：不再累加，因为outlier_points_count应该跟踪实际删除的异常点总数
        # 这里只更新outlier_points_list，实际的计数会在save_file_with_outlier_removal中更新
        print(f"[DEBUG] 步骤10完成: 发现 {outlier_count} 个异常点，当前异常点列表长度: {len(self.outlier_points_list)}")

        # 步骤11: 弹窗告知用户所有存在异常点的坐标和厚度，并询问用户是否删除异常点并再次模拟（yes or no）
        should_remove_outliers = self.show_outlier_points_dialog(outlier_points)

        if not should_remove_outliers:
            # 步骤12: 如果步骤11选择no，则结束
            print(f"[DEBUG] 步骤12完成: 用户选择不删除异常点")

            # 修复：批量模式下，用户选择不删除异常点时应该生成Recipe并继续批量处理
            if hasattr(self, 'is_batch_mode') and self.is_batch_mode:
                print(f"[DEBUG] 批量模式：用户选择跳过异常检测，生成Recipe后继续批量处理")
                # 在批量模式下，生成Recipe后继续批量处理
                if self.etching_ui and hasattr(self.etching_ui, 'generate_stage_speed_map'):
                    try:
                        print(f"[DEBUG] 批量模式：开始生成Recipe")
                        self.etching_ui.generate_stage_speed_map()
                        print(f"[DEBUG] 批量模式：Recipe生成完成")
                    except Exception as e:
                        print(f"[ERROR] 批量模式：Recipe生成失败: {str(e)}")

                # 调用批量处理继续函数
                if hasattr(self, '_batch_completion_callback'):
                    self._batch_completion_callback()
                elif self.main_window and hasattr(self.main_window, 'batch_continue_processing'):
                    self.main_window.batch_continue_processing()
                elif self.main_window and hasattr(self.main_window, '_continue_batch_processing'):
                    self.main_window._continue_batch_processing(None)
                else:
                    print(f"[ERROR] 批量处理模式：未找到批量继续处理回调")
                return
            else:
                # 单片模式：结束处理
                self._show_uniformity_failure_dialog(validated_stats, unity_msg)
                return

        # 步骤13: 如果步骤11选择yes，则进入IQR异常点删除模式
        print(f"[DEBUG] 步骤13完成: 用户同意删除异常点，进入IQR异常点删除模式")
        self.enter_iqr_outlier_mode()

        # 步骤14: 异常点删除次数=异常点删除次数+1
        self.increment_outlier_removal_count()

        # 步骤15: 将步骤6检测的初始膜厚文件删去异常点并另存为
        # 获取要删除的异常点索引
        outlier_indices = [point['index'] for point in outlier_points]
        new_file = self.save_file_with_outlier_removal(current_data, outlier_indices)

        if not new_file:
            logger.error("步骤15失败: 无法保存删除异常点后的文件")
            return

        # 步骤16: 将该文件重新传递回步骤1开始循环
        print(f"[DEBUG] 步骤16完成: 将删除异常点的文件重新传递回步骤1开始循环")

        # 计算删除异常点后的数据
        mask = np.ones(len(current_data), dtype=bool)
        mask[outlier_indices] = False
        cleaned_data = current_data[mask]

        self._restart_simulation_with_file(new_file, cleaned_data)

    def _start_min_value_removal_flow(self, current_data, validated_stats, unity_msg):
        """
        启动最小值删除流程（从步骤17开始）

        Args:
            current_data: 当前膜厚数据
            validated_stats: 验证统计信息
            unity_msg: 均匀性消息
        """
        while True:
            # 步骤17: 检测当前膜厚文件的最小值的坐标和膜厚，然后把最小值点的坐标和膜厚添加到最小值删除列表[]
            min_point_info = self.detect_current_min_value_point(current_data)

            if not min_point_info:
                logger.error("步骤17失败: 无法检测最小值点")
                self._show_uniformity_failure_dialog(validated_stats, unity_msg)
                return

            # 步骤18: 将最小值删除列表中所有最小值点的坐标和膜厚告知用户，并询问是否删除一个最小值点后再次模拟
            should_remove_min_value = self.show_min_value_removal_dialog(min_point_info, self.min_value_removal_list)

            if not should_remove_min_value:
                # 步骤19: 如果用户在步骤18选择no，则结束
                print(f"[DEBUG] 步骤19完成: 用户选择不删除最小值点，结束")
                self._show_uniformity_failure_dialog(validated_stats, unity_msg)
                return

            # 步骤20: 如果用户在步骤18选择yes，则将步骤6检测到已经不存在异常点的文件删除在步骤17检测到的最小值点
            min_index = min_point_info['index']
            mask = np.ones(len(current_data), dtype=bool)
            mask[min_index] = False
            new_data = current_data[mask]

            # 步骤21: 最小值删除个数=最小值删除个数+1
            self.increment_min_value_removal_count()

            # 步骤22: 把步骤20中删除了一个最小值点的文件另存为指定格式
            new_file = self.save_file_with_min_value_removal(new_data, min_point_info)

            if not new_file:
                logger.error("步骤22失败: 无法保存删除最小值点后的文件")
                return

            # 步骤23: 使用步骤22另存为的文件开始进行模拟
            print(f"[DEBUG] 步骤23完成: 使用删除最小值点的文件重新开始模拟")

            # 修复：批量模式下也应该继续优化流程，直到均匀性满足要求或用户选择停止
            if hasattr(self, 'is_batch_mode') and self.is_batch_mode:
                print(f"[DEBUG] 批量模式：最小值删除完成，但需要检查是否需要继续优化")
                # 在批量模式下，检查当前均匀性，如果仍不满足要求，需要继续优化
                if hasattr(self, '_check_batch_uniformity_and_continue'):
                    self._check_batch_uniformity_and_continue(new_file, new_data)
                else:
                    # 如果没有检查方法，则继续批量处理
                    print(f"[DEBUG] 批量模式：无法检查均匀性，直接继续批量处理")
                    if hasattr(self, '_batch_completion_callback') and self._batch_completion_callback:
                        self._batch_completion_callback()
                    elif self.main_window and hasattr(self.main_window, '_continue_batch_processing'):
                        self.main_window._continue_batch_processing(None)
                    else:
                        print(f"[ERROR] 批量处理模式：未找到批量继续处理回调")
                return
            else:
                # 单片模式：正常重新模拟流程
                print(f"[DEBUG] 单片模式：最小值删除完成，重新开始模拟")
                self._restart_simulation_with_file(new_file, new_data)
                return  # 这里return，等待新模拟完成后会再次调用handle_simulation_completed

    def _restart_simulation_with_file(self, new_file_path, new_data):
        """
        使用新文件重新启动模拟（步骤16和步骤23的通用方法）

        Args:
            new_file_path: 新文件路径
            new_data: 新的数据
        """
        if hasattr(self, 'simulation_callback') and self.simulation_callback:
            print(f"[DEBUG] 准备使用新文件重新模拟: {new_file_path}")
            print(f"[DEBUG] 新数据形状: {new_data.shape}")

            try:
                # 使用QTimer延迟调用，避免在异常处理循环中直接调用
                from PyQt5.QtCore import QTimer
                QTimer.singleShot(100, lambda: self.simulation_callback(new_file_path, new_data))
                print(f"[DEBUG] 已安排重新模拟，等待执行")
            except Exception as e:
                import traceback
                print(f"[ERROR] 重新模拟回调失败: {str(e)}")
                print(f"[ERROR] 详细错误: {traceback.format_exc()}")
                if self.main_window:
                    self.main_window.update_status_message(f"重新模拟失败: {str(e)}", "error")
        else:
            logger.error("未找到回调函数，无法重新模拟")
            if self.main_window:
                self.main_window.update_status_message("无法重新模拟：回调函数未设置", "error")

    def _check_batch_uniformity_and_continue(self, new_file_path, new_data):
        """
        批量模式下检查均匀性并决定是否继续优化

        Args:
            new_file_path: 新文件路径
            new_data: 新的数据
        """
        try:
            print(f"[DEBUG] _check_batch_uniformity_and_continue 开始执行")
            print(f"[DEBUG] 新文件路径: {new_file_path}")

            # 在批量模式下，自动重新模拟以检查均匀性是否改善
            # 如果均匀性仍不满足要求，会再次进入异常值检测流程
            print(f"[DEBUG] 批量模式：重新模拟以检查均匀性")
            self._restart_simulation_with_file(new_file_path, new_data)

        except Exception as e:
            print(f"[ERROR] _check_batch_uniformity_and_continue 失败: {str(e)}")
            import traceback
            print(f"[ERROR] 详细错误: {traceback.format_exc()}")
            # 出错时直接继续批量处理
            if hasattr(self, '_batch_completion_callback') and self._batch_completion_callback:
                self._batch_completion_callback()
            elif self.main_window and hasattr(self.main_window, '_continue_batch_processing'):
                self.main_window._continue_batch_processing(None)

    def _start_min_value_removal_auto(self, current_data):
        """
        自动开始最小值删除流程（根据test_outlier_debug.py推断）

        Args:
            current_data: 当前厚度数据
        """
        logger.info("开始调用_start_min_value_removal_auto...")

        thickness_values = current_data[:, 2]
        min_index = np.argmin(thickness_values)

        logger.info(f"最小值索引: {min_index}, 最小值: {thickness_values[min_index]:.2f}")

        # 执行最小值删除
        new_data = self._execute_min_value_removal_auto(current_data, min_index)

        return new_data

    def _execute_min_value_removal_auto(self, current_data, min_index):
        """
        执行自动最小值删除逻辑（根据test_outlier_debug.py推断）

        Args:
            current_data: 当前厚度数据
            min_index: 最小值索引

        Returns:
            numpy.ndarray: 删除最小值后的数据
        """
        logger.info(f"开始执行自动最小值删除，索引: {min_index}")

        # 创建掩码，移除最小值
        mask = np.ones(len(current_data), dtype=bool)
        mask[min_index] = False
        new_data = current_data[mask]

        # 更新最小值删除计数
        self.min_removed_count += 1
        logger.info(f"删除后数据点数: {len(new_data)}")

        # 保存删除后的数据
        new_file_path = self._save_min_value_removal_result(new_data)

        # 更新original_file路径（关键！）
        if new_file_path:
            self.original_file = new_file_path
            logger.info(f"更新original_file为: {self.original_file}")

        return new_data

    def _save_min_value_removal_result(self, data):
        """
        保存最小值删除结果（区分批量和单片处理）

        Args:
            data: 要保存的数据

        Returns:
            str: 保存的文件路径
        """
        try:
            # 确保有原始文件路径
            if not self.original_file:
                logger.error("original_file为None，无法保存最小值删除结果")
                return None

            # 使用初始的原始文件路径，避免嵌套目录问题
            if hasattr(self, 'base_original_file') and self.base_original_file:
                base_file_path = self.base_original_file
                logger.info(f"使用base_original_file: {base_file_path}")
            elif self.original_file:
                # 第一次调用时保存基础路径
                self.base_original_file = self.original_file
                base_file_path = self.base_original_file
                logger.info(f"设置base_original_file为: {base_file_path}")
            else:
                logger.error("无法确定原始文件路径")
                return None

            if not base_file_path:
                logger.error("base_file_path为None，无法保存最小值删除结果")
                return None

            output_dir = os.path.dirname(base_file_path)
            base_name = os.path.splitext(os.path.basename(base_file_path))[0]

            # 根据处理模式决定保存路径
            # 单片处理：直接保存到原文件目录
            target_dir = output_dir
            logger.info(f"保存最小值删除结果到: {target_dir}")

            # 生成文件名
            if self.outlier_rounds > 0:
                new_filename = f"{base_name}_error_deleted_{self.outlier_rounds}_time_min_removed_{self.min_removed_count}.csv"
            else:
                new_filename = f"{base_name}_min_removed_{self.min_removed_count}.csv"

            new_file_path = os.path.join(target_dir, new_filename)

            # 保存数据
            if self._save_thickness_data(data, new_file_path):
                logger.info(f"准备保存文件到: {new_file_path}")

                if self.main_window:
                    remaining_count = len(data)
                    original_count = self.original_count if self.original_count > 0 else len(data)
                    percentage = (remaining_count / original_count) * 100 if original_count > 0 else 100

                    mode_text = "单片处理"
                    message = f"{mode_text} - 第{self.min_removed_count}个最小值移除完成:\n"
                    message += f"- 剩余 {remaining_count} 个数据点 ({percentage:.1f}%)\n"
                    message += f"- 文件已保存为: {new_filename}"

                    self.main_window.update_status_message(message, "info")

                return new_file_path
            else:
                logger.error(f"保存文件失败: {new_file_path}")
                return None

        except Exception as e:
            logger.error(f"保存最小值删除结果时出错: {e}")
            return None

    def _process_single_outlier_cycle_enhanced(self, thickness_data, validated_stats, unity_msg):
        """
        处理单次异常值检测循环（增强版，支持自动最小值删除）

        Args:
            thickness_data: 厚度数据
            validated_stats: 验证统计
            unity_msg: 均匀性消息
        """
        if thickness_data is None:
            return

        current_data = thickness_data.copy()
        total_removed_points = 0
        cycle_num = 1
        auto_min_removal_enabled = True  # 启用自动最小值删除

        # 重置最小值删除模式状态（每次新的异常值处理开始时）
        self.min_value_removal_mode = False

        while True:
            print(f"[DEBUG] ===== 第{cycle_num}轮异常值处理开始 =====")
            print(f"[DEBUG] 当前数据点数: {len(current_data)}")

            if len(current_data) == 0:
                if self.main_window:
                    self.main_window.update_status_message("数据已全部删除，无法继续处理", "error")
                return

            # 根据模式选择处理逻辑
            if self.min_value_removal_mode:
                # 已在最小值删除模式，直接处理最小值
                print(f"[DEBUG] 已在最小值删除模式，跳过IQR检测")
            else:
                # IQR异常值检测模式（只在首次或删除异常值后执行）
                thickness_values = current_data[:, 2]
                print(f"[DEBUG] IQR异常值检测模式，厚度数据范围: {np.min(thickness_values):.2f} - {np.max(thickness_values):.2f}")

                outlier_indices, lower_bound, upper_bound, outlier_details = self._detect_outliers_1_5_iqr(thickness_values)
                print(f"[DEBUG] IQR检测结果: 异常值数量 = {len(outlier_indices)}")

                if len(outlier_indices) == 0:
                    # 没有IQR异常值，询问是否进入最小值删除模式
                    print(f"[DEBUG] 没有检测到IQR异常值，询问是否进入最小值删除模式")
                    self.min_value_removal_mode = True  # 进入最小值删除模式（实例变量）

                    if self.main_window:
                        message = f"第{cycle_num}轮IQR检测完成，未发现异常值"
                        message += f"\n当前没有IQR异常点，是否进入最小值删除模式？"
                        message += f"\n(逐轮删除最小值点并重新模拟)"

                        reply = QMessageBox.question(
                            self.etching_ui,
                            f"第{cycle_num}轮 - 进入最小值删除模式",
                            message,
                            QMessageBox.Yes | QMessageBox.No,
                            QMessageBox.Yes
                        )

                        if reply == QMessageBox.No:
                            print(f"[DEBUG] 用户选择不进入最小值删除模式，保存当前结果")
                            if self.main_window:
                                message = f"用户选择停止处理"
                                message += f"\n当前数据点数: {len(current_data)}"
                                message += f"\n{unity_msg}"
                                self.main_window.update_status_message(message, "info")
                            self._save_final_result(current_data, validated_stats, unity_msg)
                            return

                        print(f"[DEBUG] 用户同意进入最小值删除模式")

                    # 进入最小值删除处理逻辑（在IQR检测后发现无异常值时）
                    print(f"[DEBUG] ===== 进入第{cycle_num}轮最小值删除 =====")

                elif len(outlier_indices) > 0:
                    # 有IQR异常值，处理异常值
                    print(f"[DEBUG] 检测到{len(outlier_indices)}个IQR异常值，开始处理")
                    # 处理IQR异常值的逻辑会在这里执行
                    pass  # 保留原有逻辑

            # 统一的最小值删除处理逻辑
            if self.min_value_removal_mode:
                # 纯最小值删除模式 - 不再检测IQR异常值
                print(f"[DEBUG] 最小值删除模式，只处理最小值")

                # 获取当前最小值信息
                current_thickness = current_data[:, 2]
                min_thickness = np.min(current_thickness)
                min_index = np.argmin(current_thickness)
                max_thickness = np.max(current_thickness)

                print(f"[DEBUG] 第{cycle_num}轮最小值删除模式")
                print(f"[DEBUG]   最小值: {min_thickness:.2f} nm (索引: {min_index})")
                print(f"[DEBUG]   厚度范围: {min_thickness:.2f} - {max_thickness:.2f} nm")
                print(f"[DEBUG]   数据点数: {len(current_data)}")

                if self.main_window:
                    message = f"第{cycle_num}轮最小值删除模式"
                    message += f"\n厚度范围: {min_thickness:.2f} - {max_thickness:.2f} nm"
                    message += f"\n是否删除最小值点后重新模拟？"
                    message += f"\n(最小值索引: {min_index}, 厚度: {min_thickness:.2f} nm)"

                    reply = QMessageBox.question(
                        self.etching_ui,
                        f"第{cycle_num}轮 - 删除最小值点",
                        message,
                        QMessageBox.Yes | QMessageBox.No,
                        QMessageBox.No
                    )

                    if reply == QMessageBox.No:
                        print(f"[DEBUG] 用户选择停止最小值删除，保存当前结果")
                        if self.main_window:
                            message = f"用户选择停止最小值删除"
                            message += f"\n当前厚度范围: {min_thickness:.2f} - {max_thickness:.2f} nm"
                            message += f"\n数据点数: {len(current_data)}"
                            message += f"\n{unity_msg}"
                            self.main_window.update_status_message(message, "info")
                        self._save_final_result(current_data, validated_stats, unity_msg)
                        return

                # 执行最小值删除
                print(f"[DEBUG] 用户同意删除第{cycle_num}轮最小值点")
                try:
                    new_data = self._start_min_value_removal_auto(current_data)
                    total_removed_points += 1
                    print(f"[DEBUG] 第{cycle_num}轮最小值删除完成，new_data形状: {new_data.shape if new_data is not None else 'None'}")

                    # 检查数据点数量是否足够
                    if len(new_data) < self.min_data_points:
                        print(f"[DEBUG] 第{cycle_num}轮删除后数据点不足({len(new_data)} < {self.min_data_points})")
                        if self.main_window:
                            self.main_window.update_status_message("最小值删除后数据点不足，停止处理", "error")
                        self._save_final_result(new_data, validated_stats, unity_msg)
                        return

                    # 立即使用删除后的数据重新模拟
                    print(f"[DEBUG] 第{cycle_num}轮将使用删除最小值后的数据重新模拟")
                    if hasattr(self, 'simulation_callback') and self.simulation_callback:
                        # 创建临时文件用于重新模拟
                        temp_file = self._save_temp_data(new_data, f"min_removed_{cycle_num}")
                        if temp_file and os.path.exists(temp_file):
                            logger.info(f"第{cycle_num}轮使用删除最小值后的数据重新模拟: {temp_file}")
                            print(f"[DEBUG] 第{cycle_num}轮调用回调函数进行重新模拟，参数: temp_file={temp_file}")
                            try:
                                # 使用QTimer延迟调用，避免在异常处理循环中直接调用
                                from PyQt5.QtCore import QTimer
                                QTimer.singleShot(100, lambda: self._safe_callback_call(temp_file, new_data))
                                print(f"[DEBUG] 第{cycle_num}轮已安排重新模拟，本轮结束")
                            except Exception as e:
                                import traceback
                                print(f"[ERROR] 第{cycle_num}轮回调函数准备失败: {str(e)}")
                                print(f"[ERROR] 详细错误: {traceback.format_exc()}")
                        else:
                            logger.error("第{cycle_num}轮创建临时文件失败，无法重新模拟")
                    else:
                        logger.error("未找到回调函数，无法重新模拟")
                    return

                except Exception as e:
                    print(f"[ERROR] 第{cycle_num}轮最小值删除失败: {str(e)}")
                    import traceback
                    print(f"[ERROR] 详细错误: {traceback.format_exc()}")
                    break

            # IQR异常值处理逻辑
            if len(outlier_indices) > 0:
                # 有异常值，删除异常值
                print(f"[DEBUG] 检测到{len(outlier_indices)}个异常值，开始删除")
                if self.main_window:
                    removed_count = len(outlier_indices)
                    remaining_count = len(current_data) - removed_count
                    original_count = self.original_count
                    percentage = (remaining_count / original_count) * 100 if original_count > 0 else 100
                    print(f"[DEBUG] 删除统计: 原始={original_count}, 删除={removed_count}, 剩余={remaining_count}, 占比={percentage:.1f}%")

                    message = f"第{cycle_num}轮检测到{removed_count}个IQR异常值，将删除并重新模拟"
                    message += f"\n异常值范围: {lower_bound:.2f} - {upper_bound:.2f} nm"
                    message += f"\n剩余数据点: {remaining_count} ({percentage:.1f}%)"

                    # 询问用户是否继续
                    reply = QMessageBox.question(
                        self.etching_ui,
                        f"第{cycle_num}轮 - 删除IQR异常值",
                        message,
                        QMessageBox.Yes | QMessageBox.No,
                        QMessageBox.Yes
                    )

                    if reply == QMessageBox.No:
                        print(f"[DEBUG] 用户选择不删除异常值，保存当前结果")
                        self._save_final_result(current_data, validated_stats, unity_msg)
                        return

                # 移除异常值
                current_data, remaining_count = self._remove_outliers_and_save(current_data, outlier_indices, cycle_num)
                total_removed_points += len(outlier_indices)

                # 检查数据点数量是否足够
                if remaining_count < self.min_data_points:
                    print(f"[DEBUG] 剔除异常值后数据点不足({remaining_count} < {self.min_data_points})")
                    if self.main_window:
                        self.main_window.update_status_message("剔除异常值后数据点不足，停止处理", "error")
                    self._save_final_result(current_data, validated_stats, unity_msg)
                    return

                # 立即使用剔除后的数据重新模拟
                if hasattr(self, 'simulation_callback') and self.simulation_callback:
                    # 创建临时文件用于重新模拟
                    temp_file = self._save_temp_data(current_data, f"optimized_round_{cycle_num}")
                    if temp_file and os.path.exists(temp_file):
                        logger.info(f"使用优化数据重新模拟: {temp_file}")
                        print(f"[DEBUG] 调用回调函数，参数: temp_file={temp_file}, current_data形状={current_data.shape}")
                        try:
                            # 回调函数需要两个参数：(new_file_path, new_data)
                            print(f"[DEBUG] 准备调用回调函数，回调函数类型: {type(self.simulation_callback)}")
                            # 先检查文件是否正确创建
                            import pandas as pd
                            check_df = pd.read_csv(temp_file)
                            print(f"[DEBUG] 临时文件检查: 形状={check_df.shape}, 列名={list(check_df.columns)}")

                            # 确保current_data格式正确
                            print(f"[DEBUG] current_data类型: {type(current_data)}, 形状: {current_data.shape}")
                            if current_data.shape[1] >= 3:
                                print(f"[DEBUG] current_data前3行: {current_data[:3]}")

                            # 使用QTimer延迟调用，避免在异常处理循环中直接调用
                            from PyQt5.QtCore import QTimer
                            QTimer.singleShot(100, lambda: self._safe_callback_call(temp_file, current_data))
                            print(f"[DEBUG] 已安排重新模拟，本轮结束")

                        except Exception as e:
                            import traceback
                            print(f"[ERROR] 回调函数准备失败: {str(e)}")
                            print(f"[ERROR] 详细错误: {traceback.format_exc()}")
                    else:
                        logger.error("创建临时文件失败，无法重新模拟")
                else:
                    logger.error("未找到回调函数，无法重新模拟")
                return

            cycle_num += 1

            # 防止无限循环
            if cycle_num > self.max_outlier_rounds:
                logger.warning(f"达到最大异常值处理轮次 ({self.max_outlier_rounds})，停止处理")
                break

        # 保存最终结果
        self._save_final_result(current_data, validated_stats, unity_msg)

    def _process_single_outlier_cycle(self, thickness_data, validated_stats, unity_msg):
        """
        处理单次异常值检测循环

        Args:
            thickness_data: 厚度数据
            validated_stats: 验证统计
            unity_msg: 均匀性消息
        """
        if thickness_data is None:
            return

        current_data = thickness_data.copy()
        total_removed_points = 0
        cycle_num = 1

        while True:
            if len(current_data) == 0:
                if self.main_window:
                    self.main_window.update_status_message("数据已全部删除，无法继续处理", "error")
                return

            # 检测异常值
            thickness_values = current_data[:, 2]
            outlier_indices, lower_bound, upper_bound, outlier_details = self._detect_outliers_1_5_iqr(thickness_values)

            if len(outlier_indices) == 0:
                # 没有异常值，开始最小值删除流程
                if self.main_window:
                    self.main_window.update_status_message(f"第{cycle_num}轮：没有检测到异常值，开始最小值删除流程", "info")

                # 询问用户是否继续
                if not self._ask_user_continue_min_removal(cycle_num):
                    # 保存当前结果并退出
                    self._save_final_result(current_data, validated_stats, unity_msg)
                    return

                # 移除最小值
                current_data, min_index = self._remove_min_values_and_save(current_data, 0, total_removed_points)
                if min_index >= 0:
                    total_removed_points += 1

                # 使用修改后的数据重新模拟
                if hasattr(self, 'simulation_callback') and self.simulation_callback:
                    # 创建临时文件用于重新模拟
                    temp_file = self._save_temp_data(current_data, f"min_removed_{cycle_num}")
                    if temp_file and os.path.exists(temp_file):
                        logger.info(f"使用最小值删除数据重新模拟: {temp_file}")
                        # 使用QTimer延迟调用，避免多线程问题
                        from PyQt5.QtCore import QTimer
                        QTimer.singleShot(100, lambda: self._safe_min_callback_call(temp_file, current_data))
                    else:
                        logger.error("创建临时文件失败，无法重新模拟")
                    return
                return
            else:
                # 有异常值，删除异常值
                if self.main_window:
                    removed_count = len(outlier_indices)
                    remaining_count = len(current_data) - removed_count
                    original_count = self.original_count
                    percentage = (remaining_count / original_count) * 100 if original_count > 0 else 100

                    message = f"第{cycle_num}轮异常值检测:\n"
                    message += f"- 检测到 {removed_count} 个异常点 (1.5倍IQR方法)\n"
                    message += f"- 剩余 {remaining_count} 个数据点 ({percentage:.1f}%)\n"
                    message += f"- 异常值范围: {lower_bound:.2f} - {upper_bound:.2f} nm"

                    self.main_window.update_status_message(message, "info")

                # 移除异常值
                current_data, remaining_count = self._remove_outliers_and_save(current_data, outlier_indices, cycle_num)
                total_removed_points += len(outlier_indices)

                # 检查是否需要继续处理
                if remaining_count < self.original_count * 0.8:  # 少于80%的数据点
                    if not self._ask_user_continue_outlier_removal(cycle_num, remaining_count, total_removed_points):
                        # 保存当前结果并退出
                        self._save_final_result(current_data, validated_stats, unity_msg)
                        return

                # 使用修改后的数据重新模拟
                if hasattr(self, 'simulation_callback') and self.simulation_callback:
                    # 创建临时文件用于重新模拟
                    temp_file = self._save_temp_data(current_data, f"outlier_removed_{cycle_num}")
                    self.simulation_callback()
                return

            cycle_num += 1

    def _save_temp_data(self, data, suffix):
        """
        保存临时数据用于重新模拟

        Args:
            data: 数据数组
            suffix: 文件后缀

        Returns:
            str: 临时文件路径
        """
        base_name = os.path.splitext(os.path.basename(self.original_file))[0]
        temp_filename = f"{base_name}_temp_{suffix}.csv"
        temp_file_path = os.path.join(os.path.dirname(self.original_file), temp_filename)

        self._save_thickness_data(data, temp_file_path)
        return temp_file_path

    def _safe_callback_call(self, temp_file, current_data):
        """
        安全地调用回调函数，避免多线程冲突

        Args:
            temp_file: 临时文件路径
            current_data: 当前数据数组
        """
        try:
            print(f"[DEBUG] _safe_callback_call 开始")
            print(f"[DEBUG] temp_file: {temp_file}")
            print(f"[DEBUG] current_data形状: {current_data.shape}")

            # 确保回调函数存在
            if self.simulation_callback:
                print(f"[DEBUG] 调用回调函数")
                self.simulation_callback(temp_file, current_data)
                print(f"[DEBUG] 回调函数调用完成")
            else:
                print(f"[ERROR] 回调函数不存在")
        except Exception as e:
            import traceback
            print(f"[ERROR] _safe_callback_call 失败: {str(e)}")
            print(f"[ERROR] 详细错误: {traceback.format_exc()}")

    def _safe_min_callback_call(self, temp_file, current_data):
        """
        安全地调用回调函数用于最小值删除后重新模拟，避免多线程冲突

        Args:
            temp_file: 临时文件路径
            current_data: 当前数据数组
        """
        try:
            print(f"[DEBUG] _safe_min_callback_call 开始")
            print(f"[DEBUG] temp_file: {temp_file}")
            print(f"[DEBUG] current_data形状: {current_data.shape}")

            # 确保回调函数存在
            if self.simulation_callback:
                print(f"[DEBUG] 调用回调函数（最小值删除后）")
                self.simulation_callback(temp_file, current_data)
                print(f"[DEBUG] 回调函数调用完成")
            else:
                print(f"[ERROR] 回调函数不存在")
        except Exception as e:
            import traceback
            print(f"[ERROR] _safe_min_callback_call 失败: {str(e)}")
            print(f"[ERROR] 详细错误: {traceback.format_exc()}")

    def _ask_user_outlier_removal_initial(self, uniformity, uniformity_threshold, unity_msg):
        """
        首次询问用户是否要进行基于四分位数的异常值剔除

        Args:
            uniformity: 当前均一性值
            uniformity_threshold: 均一性阈值
            unity_msg: 均一性消息

        Returns:
            bool: 用户选择是否进行异常值剔除
        """
        from PyQt5.QtWidgets import QMessageBox

        title = "模拟结果不佳 - 异常值处理询问"
        message = f"模拟完成，但结果验算的均一性不达标：\n\n"
        message += f"{unity_msg}\n\n"
        message += f"当前均一性: {uniformity:.2f}%\n"
        message += f"设定阈值: {uniformity_threshold:.2f}%\n"
        message += f"差异: {uniformity - uniformity_threshold:.2f}%\n\n"
        message += "系统可以基于四分位数算法自动检测并剔除异常数据点，\n"
        message += "然后重新进行模拟以改善均一性。\n\n"
        message += "是否要进行基于四分位数的异常值剔除？"

        reply = QMessageBox.question(
            self.etching_ui,
            title,
            message,
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No  # 默认选择否，更安全
        )

        # 记录用户选择
        if reply == QMessageBox.Yes:
            if self.main_window:
                self.main_window.update_status_message("用户选择进行异常值剔除", "info")
            logger.info(f"用户选择进行异常值剔除 (均一性: {uniformity:.2f}% > 阈值: {uniformity_threshold:.2f}%)")
        else:
            if self.main_window:
                self.main_window.update_status_message("用户选择不进行异常值剔除", "warning")
            logger.info(f"用户选择不进行异常值剔除 (均一性: {uniformity:.2f}% > 阈值: {uniformity_threshold:.2f}%)")

        return reply == QMessageBox.Yes

    def _show_uniformity_failure_dialog(self, validated_stats, unity_msg):
        """
        显示用户拒绝异常值处理后的均匀性不达标对话框

        Args:
            validated_stats: 验证统计信息
            unity_msg: 均一性消息
        """
        from PyQt5.QtWidgets import QMessageBox

        title = "模拟完成 - 用户未选择优化"
        message = f"刻蚀模拟已完成，但均一性未达到设定的阈值标准。\n\n"
        message += f"{unity_msg}\n\n"
        message += "您可以选择：\n"
        message += "1. 调整高级选项中的均一性阈值\n"
        message += "2. 检查输入的膜厚数据质量\n"
        message += "3. 重新运行模拟并选择异常值剔除\n\n"
        message += "模拟结果已保存到输出目录。"

        QMessageBox.warning(self.etching_ui, title, message)

        if self.main_window:
            self.main_window.update_status_message("模拟完成，但用户未选择进行异常值优化", "warning")

    def _ask_user_continue_outlier_removal(self, cycle_num, remaining_count, total_removed_points):
        """
        询问用户是否继续异常值处理

        Returns:
            bool: 用户选择是否继续
        """
        from PyQt5.QtWidgets import QMessageBox

        title = f"第{cycle_num}轮异常值处理完成"
        message = f"当前数据点数: {remaining_count}\n"
        message += f"相比原始文件共移除了 {total_removed_points} 个异常点\n\n"
        message += f"剩余数据点数: {remaining_count} ({(remaining_count/self.original_count*100):.1f}%)\n\n"
        message += "是否继续修改膜厚数据并重新进行模拟？"

        reply = QMessageBox.question(self.etching_ui, title, message,
                                   QMessageBox.Yes | QMessageBox.No,
                                   QMessageBox.No)

        return reply == QMessageBox.Yes

    def _ask_user_continue_min_removal(self, cycle_num):
        """
        询问用户是否继续最小值删除

        Returns:
            bool: 用户选择是否继续
        """
        from PyQt5.QtWidgets import QMessageBox

        title = f"第{cycle_num}轮处理"
        message = f"当前没有检测到异常值，但均匀性仍然不达标。\n\n"
        message += "是否开始最小值删除流程？"

        reply = QMessageBox.question(self.etching_ui, title, message,
                                   QMessageBox.Yes | QMessageBox.No,
                                   QMessageBox.No)

        return reply == QMessageBox.Yes

    def _show_uniformity_success_dialog(self, validated_stats, unity_msg):
        """
        显示均匀性达标对话框
        """
        from PyQt5.QtWidgets import QMessageBox

        QMessageBox.information(self.etching_ui, "模拟完成",
                              f"刻蚀模拟完成！\n\n{unity_msg}")

    def _save_final_result(self, final_data, validated_stats, unity_msg):
        """
        保存最终结果
        """
        base_name = os.path.splitext(os.path.basename(self.original_file))[0]
        final_filename = f"{base_name}_final_result.csv"
        final_file_path = os.path.join(os.path.dirname(self.original_file), final_filename)

        if self._save_thickness_data(final_data, final_file_path) and self.main_window:
            remaining_count = len(final_data)
            percentage = (remaining_count / self.original_count) * 100 if self.original_count > 0 else 100
            total_removed = self.original_count - remaining_count

            message = f"模拟处理完成!\n\n"
            message += f"原始数据点数: {self.original_count}\n"
            message += f"最终数据点数: {remaining_count} ({percentage:.1f}%)\n"
            message += f"总共移除: {total_removed} 个点\n"
            message += f"最终文件: {final_filename}\n\n"
            message += f"{unity_msg}"

            self.main_window.update_status_message(message, "info")

        # 检查是否是批量处理模式
        if hasattr(self, 'is_batch_mode') and self.is_batch_mode:
            print(f"[DEBUG] 批量处理模式：异常检测完成，生成Recipe后继续批量处理")
            # 在批量模式下，异常检测完成后需要生成Recipe
            if self.etching_ui and hasattr(self.etching_ui, 'generate_stage_speed_map'):
                try:
                    print(f"[DEBUG] 批量模式：开始生成Recipe")
                    self.etching_ui.generate_stage_speed_map()
                    print(f"[DEBUG] 批量模式：Recipe生成完成")
                except Exception as e:
                    print(f"[ERROR] 批量模式：Recipe生成失败: {str(e)}")

            # 调用批量处理继续函数
            if hasattr(self, '_batch_completion_callback'):
                self._batch_completion_callback()
            elif self.main_window and hasattr(self.main_window, 'batch_continue_processing'):
                self.main_window.batch_continue_processing()
            elif self.main_window and hasattr(self.main_window, '_continue_batch_processing'):
                self.main_window._continue_batch_processing(None)
            else:
                print(f"[ERROR] 批量处理模式：未找到批量继续处理回调")